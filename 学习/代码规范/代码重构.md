## 代码重构

- **重构并不等于过度封装！！！**

  新手程序员, 最容易犯了过度封装的错误的原因就是不知道何时适可而止, 脑筋往往不断地分解分解再分解问题, 最后, 你看到的就是这个调用那个, 那个引用这个, 乱七八糟毫无头绪, 三两行代码的函数比比皆是, 自以为封装抽象, 其实是拿捏不好这个度.

- 概念：

  什么是代码重构？每个人对他的理解总是不一样的，但总的方向是一致的！

在不改变原有代码功能的前提下，使代码更加简洁干净，提高其可阅读性，降低修改成本！这是我对他的理解。

​		另一个对重构的理解是，对软件内部结构的一种调整，同样也是为了使得软件的结构的清晰，降低修改和维护成本。

> ​	**傻瓜都知道编写计算机能看懂的代码，而只有优秀的程序员才能写出人可以看懂的代码！**



#### 重构的作用

- 重构能够帮助我们理解代码
- 重构能够帮助我们找bug
- 重构能够提高我们的编程速度与生产效率



#### 何时重构？

​		重构不应该是为了重构而重构，他应该是一种日常的行为，我们之所以去重构是因为我们想要去做一件事，而重构能够帮助我们把这件事做好。 

​	**Don Robort 给了我们三次法则，用来告诉我们何时重构**：当我们第一次做某事的时候尽管去做，当我们第二次做类似的事情的时候我们会产生反感，但我们仍然会去做，当我们第三次做类似的事，你就应该重构了。



##### 添加新功能时重构

​	我们最常见的就是在添加功能时进行重构。此时，重构的直接原因是我们需要更好的理解代码，这些代码可能是我们自己写的，也可能是我们自己写的，无论如何，只要当我们想要理解代码时，我们就因该思考：这段代码是否能够重构，使我快速理解他。这么做的部分原因是因为它能够使我下次阅读时跟好的理解。

##### 修补错误时重构

​	调试过程中进行重构的原因是我们想要更好的代码阅读性。你可以这么想，当我们收到一份错误报告时，就是需要重构的信号，因为代码还不够清晰，清晰到我能够一眼看出bug！

##### 复审代码时重构 

​	**公司之中的代码复审可以将有经验的公司员工将他的经验分享给其他员工**，有助公司员工的发展，同时复审可以帮助我复审别人的代码，一但我们想到一些点子就可以考虑是否能够通过重构轻松的实现，如果可以，我们就立马动手，经过多次实践，使得我们可以有更高层次的理解。**重构还可以帮助代码复审有更加具体的结果**。





#### 重构原则

- 隔离变化：很可能我在两个不同的地点使用同一个对象，而其中一个地点我想要改变对象的行为，但如果修改了他，就要冒同时影响两处的风险。为此我做出一个子类，并在需要修改的地方引用这个子类。现在我们可以修改这个子类而不必担心会影响其他地方！
- 封装条件逻辑：是指条件关系比较复杂时，代码的可读性会比较差，**所以这时我们应当根据条件表达式是否需要参数将条件表达式提取成可读性更好的属性或者方法**，如果条件表达式不需要参数则可以提取成属性，如果条件表达式需要参数则可以提取成方法。

```java
//重构之前 
public string PerformCoolFunction(string buttonPressed)
         {
  					 //	重构之前 
             if (Functions.Length > 1 && Name == "RCA" && CreatedYear > DateTime.Now.Year - 2)
                 return "doSomething";
             return string.Empty;
         }


//重构之后
private bool HasExtraFunctions
         {
             get { return Functions.Length > 1 && Name == "RCA" && CreatedYear > DateTime.Now.Year - 2; }
         }
 
         public string PerformCoolFunction(string buttonPressed)
         {
           //重构之后
             if (HasExtraFunctions)
                 return "doSomething";
             return string.Empty;
         }
```



#### 何时不应该重构

- 当快到项目的最后期限时，你应该尽量避免重构。重构过程赢得的生产力只能在最后期限之后体现出来，而那个时候已经为时已晚。前人经验告诉我们：重构的确能够提高我们的生产力。但如果已经没有足够的时间了，说明你早就应该进行重构了。



#### 重构与设计

​	重构与设计彼此互补，初学编程的时候，我埋头写程序，浑浑噩噩的开发，然后很快我发现**预先做好设计能够为我节省大量的返工时间。** 当然现在的我也认可 **预先设计** 的观点（2021/07/22），但是还有另一种观点：**重构可以代替预先设计**。意思是我们可以随意编程，让程序运行起来，之后再对他重构成型。事实上这样的办法也是可行的，极限编程「Beck XP」的支持者极力推荐这样的方法。但这些支持者同样也会进行**预先设计**，但这并不是重点。

​	重点是当重构改变了预先设计的角色，在没有重构的时候我们必须保证设计的绝对正确性，这也就导致了我们设计时的小心翼翼，这也就意味着对原始设计的修改代价太大了，而重构的出现让我们可以在设计时选择一个足够合理的方案就可以了。重构使得软件设计向简化前进了一大步。



#### 代码的坏味道（在什么地方或什么时候重构）

##### Duplicated Code （重复代码）

​	一段重复的代码一定是不合格的代码，试想一下程序之中到处都是重复的代码，这是多么糟糕的事情。

- 同一个类的两个函数含有相同的表达式，这个时候可以提炼出相同的代码，让两个函数都调用它。
- 两个互为兄弟的子类内含有相同的代码，这时我们将相同的部分推向超类，如果代码只是类似并不是完全相同我们可以将相似部分和差异部分分割开，构成一个单独的函数。
- 如果两个毫不相关的类，出现了重复代码，那么我们可以考虑将相同部分单独提出来构成一个类。

##### Long Method（过长函数）

​	面向对象的 ‘’间接层‘’ 带来的全部利益——解释能力，共享能力，选择能力。都是由小型函数支持的。



##### Large Class （过大的类）

 如果一个类的做的事情太多了，那么会出现大量的实例对象，这个时候 Duplicated Code 就出现了。



##### Long Parameter List（过长参数列）



##### Divergent Change （发散式变化）

如果某个类经常因为不同的原因在不同的方向上进行变化，Divergent Change  就出现了，当一个类，“新增一个数据库时需要修改三个函数，新出现一种交通工具时就必须修改这四个函数”，那么此时将这个对象分为两个更好；



##### Shotgun Surgery（霰弹式修改）

如果每遇到一种变化，就必须在许多不同的类之中做出许多小修改，那么你所面临的就是 霰弹式修改了；这种情况我们应该把需要的修改的代码放进同一个类。如果眼下没有合适的类，那么就创建一个。这可能造成少量的 Divergent Change 



##### Divergent Change & Shotgun Surgery

Divergent Change 是指“一个类受多种变化的影响“。

Shotgun Surgery 是指“一种变化引发多个类的修改“。



##### Feature Envy（依恋情结）

函数对于某个类的兴趣，高于对自己类的兴趣。书中作者的无数次经验告诉我们，某个函数为了计算一个值，从另一个对象哪儿调用半大的取值函数，那么此时我们就应该将函数移到它应该待的地方。如果函数中只有一部分是有依恋情结的那么就把这一部分的函数提炼出来，再移动函数。那么我们的判断依据就是：**那个类拥有最多的被此函数使用的数据我们就应该把函数移到该类之中。**





#####  Data Clumps ( 数据泥团)

两个类之中相同的数据项，许多函数签名之中相同的参数。**这些总是绑在一起出现的数据应该拥有他们自己的对象**。然后将注意力放在函数签名上，我们用对象代替参数，不必在意只是用对象上的一部分数据项，只需要知道如果对象代替了两个或以上的参数那么这就是值得的！

一个好的评判方法就是：**删除众多数据项之中的一个，如果其它数据项不再有意义，那么这就是一个明确的信号了！你需要创建一个新的对象了！**

一旦我们创建了对象，那么不只是代码中坏的味道消失了，我们更有机会可以让代码散发一股芳香！比如创建对象之后我们可以寻找：Feature Envy 。





#####  Primitive Obsession（基本类型的偏执）

我们通常不愿意再小的任务上创建对象，比如：结合数值和币种的Money 类，由一个起始数值和结束数值够成的 Range 类 等等.





##### Switch Statement（Switch 惊悚现身）

面向对象程序的一个特点就是：少用 switch 或 case 。一旦看到switch语句你就应该考虑使用多态来替换它，唯一的问题是应该考虑多态出现在哪里。**后续解决方法探索中（待解决）**



#####  平行继承体系（有待理解加深）

平行继承体系其实就是 Shotgun Change 的特殊形式。当我们增加一个类的子类的时候，也必须为另一个类添加子类。消除这种重复性的策略一般是：让一个继承体系的实例引用另一个继承体系的实例。在运用Move Method 和 Move Field 就可以将引用端的继承体系消弭于无形。



##### Lazy Class （冗赘类）

当一个类失去它应有的价值时，我们花时间去维护它，理解它是非常不值得的。项目中当我们进行代码重构使得某个类的功能大大缩减，或者一个在设计之初用来应对某些变换，然后变化没有出现的类。对于这小类我们通常采用 **collapse hierarchy （折叠继承）**或**Inline Class （合并类）**来处理。





##### Temporary Field （令人迷惑的暂时字段）

如果一个复杂的算法之中，需要好几个变量，往往会导致坏味道的 Temporary Field 。由于实现者不想要传递一长串的参数（重构之中有对长串参数的处理），所以都把这些参数放入字段，但这些字段只在该算法用到的时候才有意义，其它时候只能让人疑惑，这个时候就可以使用 Extract Class 把这些变量和其相关的函数提炼到一个独立的类之中。



#####  Message Chain（过度耦合的消息链）

一个对象请求另一个对象，另一个对象请求另一个对象....这就是消息链。实际代码中可能是一长串的 getThis()或一长串的临时变量。采用这种方式，意味着客户代码将与查找过程之中导航结构紧密耦合，一旦对象关系发生任何改变，客户端不得不做出修改。

这时我们可以使用 Hide Delegate （隐藏委托）。我们可以在消息链的不同位置使用，但往往这样会把一系列对象变成 Middle Man 。通常更好的选择是：查看消息链得到的对象最终是用来干什么的，看看能否使用 Extract Method 把该对象提炼到一个独立函数之中，再使用Move Method 把这个函数推入消息链。



##### Middle Man（中间人）

对象的基本特征之一是封装，对外部隐藏内部细节。因此当我们过度使用委托时，可能会造成中间对象全是在做无用功。这时候我们可以使用 Remove Middle Man ，直接和真正负责的对象打交道。如果这些 “ 不干实事” 的函数只有少数几个，那么可以使用Inline Method （合并函数）把他们放入调用端。如果这些 Middle Man 还有其它行为，那么我们可以把他们变成负责实事对象的子类，这样既可以扩展原对象的行为，又不必负担太多的委托。



##### Inappropriate Intimate（狎昵关系）

 当两个类过于紧密，我们需要花费大量的时间去探究彼此的 private 成分时，我们就需要用 Move Field 和 Move Method 帮助他们划清界线。当他们实在是非常紧密相连的时候，我们可以使用 Extract Class 把他们之间的共同点都提炼的同一个类之中，让他们共同使用这个类。也可以使用 Hide Delegates ，使用委托来帮助他们使用这个共同的类。 



##### Alternative Classes with Different Interfaces（异曲同工的类）

如果两个函数做着同样的事，却有着不同的签名，请运用 Rename Method 根据他们之间的用途进行命名。但这往往不够，你需要使用Move Mehod 将对应的方法移动到对应的类之中，直到这些他们之间的签名相同。



##### Data Class （纯稚的数据类）

如果一个类之中只有它拥有的字段，和取值/设置操作，那么他就是一个纯稚的数据类，它相当于一个不会说话的哑巴，我们可以找到这些字段被调用的地方，使用 Move Method 将整个函数都搬移到 数据类之中，如果无法搬移整个函数，则使用Extract Method 产生一个可以搬移的函数。不久之后你就可以运用 hide Method 把这些设置/取值函数都隐藏。



##### Comments （过多的注释）

我们常常发现过多的注释往往是因为代码的糟糕，因此我们在考虑注释的时候应该先运用之前的手段将代码重构，而重构之后的代码会变的非常清楚，此时注释就显得有点多余了，因此我们才会说过多的注释，但你要清楚我并不是说注释不好！



> ​	当你要写注释时先尝试重构，试着让注释变的多余。









#### 重新组织函数

##### Extract Method （提炼函数）

##### Inline Method （内联函数）

将相同功能的函数整合等

##### Inline Temp （内联临时变量）

##### Replcae Temp with Query（以查询代替变量）

##### Introduce Explaining Variable （引入解释性变量） 

##### Split Temporary Variable （分解临时变量）

##### Replace Method with Method Object （以函数对象取代函数）

##### Substitute Algorithm （替换算法） 

用更有简洁的算法替换当前算法





#### 在对象之间搬移特性

##### Move Method （ 搬移函数）

##### Move Field （搬移字段）

#####  Extract Class（提炼类）

##### Remove Middle Man（移除中间人）

##### Introduce Foreign Method （引入外加函数）

##### Introduce Locale Extension（引入本地扩展（如：工具类））



##### 重新组织数据

##### Self Encapsulate Field （自封装字段）

你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。![](https://i.loli.net/2021/07/26/FIBDNh1CwvedrVl.png)

##### Replace Data Value with Object （以对象取代数据值）

开发初期往往会使用简单的数据项表示简单的情况，但随着时间的推移，可能这些数据不在简单，比如：电话号码，一开始可能只是一个简单的电话号码字段，但后面又需要号码格式化，抽取区号，抽取尾号，等等特殊行为，此时如果相关函数放入数据项，那么很快 Duplicate Code 和 Feture Envy 很快就会出现。

##### Change Value to Reference （将值对象改为引用对象）-->有待理解

##### Change Reference to Value （将引用对象改为值对象） 

你有一个引用对象，很小且不可变，而且不易管理，这个时候就应该改为值对象。

##### Replace Array with Object（对象取代数组）

##### Duplicate Observed Data （复制“被监视数据”） -->有待理解

##### change Bidirectional Association Unidirectional （将双向关联改为单向关联）

##### Replace Magic Number with Symboilc  Constant （以字面常量代替魔法值）

##### Encapsulate Collection （封装集合）

##### Replace Type Code with Class （以类取代类型码）血型为例

##### Replace Type Code with SubClasses（以子类取代类型码） 

##### Replace SubClass with Field（以字段取代子类）



#### 简化条件表达式

##### Decompose Conditional（分解条件表达式，将条件抽取出来为独立的函数）

##### Consolidate Conditional Expression（合并条件表达式）

##### Consolidate Duplicate Conditional Fragments （合并重复条件片段） 

##### Replace Conditional with Polymorphism（使用多态取代条件表达式）

![](https://i.loli.net/2021/07/26/5TDfR3NhvZnbmSo.png)

##### Replace Nested Conditional with Guard Clauses（以卫语句代替嵌套条件表达式）

较为简单的一种是以下的案例：

![](https://i.loli.net/2021/07/27/wiT52rMPthORXd4.png)

同时遇到复杂的我们可以考虑将条件反转：

![](https://i.loli.net/2021/07/27/itbZwoDgcRO2HU5.png)

##### Introduce Null Object（用对象代替空检查）

代替 null 检查，返回一个继承了源对象的空对象。

![image-20210727101517023](/Users/edz/Library/Application Support/typora-user-images/image-20210727101517023.png)



##### Introduce Assertion 

为了确保部分代码的正常工作，某些条件值必须是正确的。这样当出现错误时，他会报错，这样比中指 execute 要好得多。

```java
double getExpenseLimit() {
  // Should have either expense limit or
  // a primary project.
  return (expenseLimit != NULL_EXPENSE) ?
    expenseLimit :
    primaryProject.getMemberExpenseLimit();
}


//重构后
double getExpenseLimit() {
  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != null);

  return (expenseLimit != NULL_EXPENSE) ?
    expenseLimit:
    primaryProject.getMemberExpenseLimit();
}
```





#### 简化函数调用

##### Rename Method（函数改名）

函数名无法揭示函数用途

##### Add Parameter （添加参数）

事实上我们经常添加参数，当我们的函数因为修改而需要一个参数的时候，我们往往会添加一个参数，然而在前面我们已经说过了，过长的参数，会导致Data Clumps（数据泥团）。因此实际中一旦我们有更好的选择的时候一定不要选择添加参数，比如思考你是否能够从这些参数里的到所需要的信息，这些信息用户何处，这个函数是否应该属于拥有该信息的那个对象所有？！**也许我们可以使用 Introduce Parameter Object。**

##### Remove Parameter (移除参数)

程序员往往喜欢添加参数，而不喜欢删除参数，因为他们总是觉得多余的参数不会影响代码，以后可能还会用到，然后这是一个非常错误的思想，不同的参数代表的含义也不相同，同时也意味着用户要多耗费一份心思去关心一个参数。

当然多态函数情况可能不同，不同的多态函数实现可能会使用到不同的参数。



##### Separate Query from Modify（将查询函数和修改函数分离）

建立两个函数将查询和修改进行分离。

<img src="/Users/edz/Library/Application Support/typora-user-images/image-20210727112651772.png" alt="image-20210727112651772" style="zoom:50%;" />

左边的是查询与修改和在一起的函数，而右边是分离的函数。我们将修改和查询分离可以是的函数没有任何的副作用，是一个非常干净的函数。我们可以任意的将函数放在任何地方而不用担心有什么副作用（修改其值）。我们应该将他当作一条规则，尽量去遵守他。



##### Parameterize Method （令函数携带参数）

我们可能会遇到这样的情况，两个函数的功能相似，只有少数几个值的区别使得他的行为发生了改变。我们可以使用参数将其函数合并，用参数代替那些致使行为发生改变的值。



##### Replace Parameter with Explicit Method （以明确的函数取代参数）

针对该参数的每一个值设立一个独立的函数。



##### Perserve Whole Object （保持对象的完整性）

你可能会将对象中的某些值作为参数取出后传递给某个函数，这样的问题在于：玩万一将来被调用函数需要更新数据项，那么你就要修改所有对此函数的调用。如果你把这些数据所属的对象传过去就不有这样的事情发生。除了使参数更稳定之外，还可以使得代码的可读性更高。



##### Replace Parameter with Method （以函数取代参数）



 
